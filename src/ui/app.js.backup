
// State
let scanData = null;
let selectedPaths = new Set();
let currentCategory = null;
let isScanning = false;
let config = {};
let categoryOverrides = {}; // { id: 'safe' | 'risky' }

// Localization Removed
function t(key) { return key; } // No-op
function updateTexts() { } // No-op

function updateTexts() {
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        el.textContent = t(key);
    });
}

// Utils
const formatSize = (bytes) => {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
};

// --- Init ---
async function init() {
    // Load config first
    try {
        const res = await fetch('/api/settings');
        config = await res.json();
        categoryOverrides = config.categoryOverrides || {};
        updateTexts();
    } catch (e) { console.error(e); }

    // Load initial scanners metadata to draw empty cards
    try {
        const res = await fetch('/api/scanners');
        const scanners = await res.json();
        renderEmptyDashboard(scanners);
    } catch (e) { console.error(e); }

    loadDiskInfo();

    // Connect SSE for background progress
    connectSSE();
}
window.onload = init;


// --- SSE Scanning ---
function connectSSE() {
    const eventSource = new EventSource('/api/scan/events');

    eventSource.onmessage = (event) => {
        const msg = JSON.parse(event.data);

        if (msg.type === 'connected') {
            console.log('SSE Connected');
        } else if (msg.type === 'progress') {
            // Update Card
            updateProgress(msg.id, msg.totalSize, msg.itemsCount);
        } else if (msg.type === 'complete') {
            isScanning = false;
            scanData = msg.summary;

            // Auto-select safe items on complete
            selectedPaths.clear();
            scanData.results.forEach(r => {
                if (r.items.length > 0 && getSafety(r.category.id, r.category.safetyLevel) === 'safe') {
                    r.items.forEach(i => selectedPaths.add(i.path));
                }
            });

            renderDashboard(); // Re-render with full data and sorting
            document.querySelectorAll('.progress-bar-fill').forEach(el => el.style.width = '0%');
        } else if (msg.type === 'error') {
            alert('Scan error: ' + msg.message);
            isScanning = false;
        }
    };

    eventSource.onerror = (err) => {
        console.error('SSE Error', err);
        // Retry logic is built-in to EventSource usually
    };
}

function updateProgress(id, size, count) {
    const card = document.querySelector(`.category-card[data-id="${id}"]`);
    if (!card) return;

    // Animate progress bar to 100% just to show activity? 
    // Or if we know total items beforehand... we don't.
    // So just show "Scanned X items" and maybe a spinner or pulse.

    const countEl = card.querySelector('.count');
    if (countEl) countEl.textContent = `${count} Scanned`;

    const sizeEl = card.querySelector('.size');
    if (sizeEl) sizeEl.textContent = formatSize(size);

    const bar = card.querySelector('.progress-bar-fill');
    if (bar) bar.style.width = '100%';

    const text = card.querySelector('.progress-text');
    if (text) text.textContent = `${count} items`;

    card.classList.remove('scanning');
}

window.startScan = async () => {
    if (isScanning) return;
    isScanning = true;

    // Reset UI
    document.querySelectorAll('.category-card').forEach(card => {
        card.classList.add('scanning');
        card.querySelector('.progress-bar-fill').style.width = '20%'; // Indeterminate start
        card.querySelector('.progress-text').textContent = 'Scanning...';
    });

    try {
        // Trigger scan
        await fetch('/api/scan/start', { method: 'POST' });
    } catch (e) {
        alert(e);
        isScanning = false;
    }
};

// --- Dashboard & Drag Drop ---
function getSafety(categoryId, defaultSafety) {
    if (categoryOverrides[categoryId]) return categoryOverrides[categoryId];
    return defaultSafety; // Respect default (safe, moderate, risky)
}


function renderEmptyDashboard(scanners) {
    const safeContainer = document.getElementById('safe-categories');
    const modContainer = document.getElementById('moderate-categories');
    const riskyContainer = document.getElementById('risky-categories');

    if (safeContainer) safeContainer.innerHTML = '';
    if (modContainer) modContainer.innerHTML = '';
    if (riskyContainer) riskyContainer.innerHTML = '';

    scanners.forEach(s => {
        const safety = getSafety(s.id, s.safetyLevel);
        const card = createCard(s.id, s.name, 0, 0, safety);
        if (safety === 'safe') safeContainer.appendChild(card);
        else if (safety === 'moderate' && modContainer) modContainer.appendChild(card);
        else riskyContainer.appendChild(card);
    });
}

function renderDashboard() {
    if (!scanData) return;
    const safeContainer = document.getElementById('safe-categories');
    const modContainer = document.getElementById('moderate-categories');
    const riskyContainer = document.getElementById('risky-categories');

    if (safeContainer) safeContainer.innerHTML = '';
    if (modContainer) modContainer.innerHTML = '';
    if (riskyContainer) riskyContainer.innerHTML = '';

    // Sort by size desc
    const sortedResults = [...scanData.results].sort((a, b) => b.totalSize - a.totalSize);

    sortedResults.forEach(r => {
        if (r.items.length === 0) return;


        const safety = getSafety(r.category.id, r.category.safetyLevel);
        const card = createCard(r.category.id, r.category.name, r.totalSize, r.items.length, safety);

        // Sync checkbox state
        const input = card.querySelector('.card-checkbox input');
        const allSelected = r.items.length > 0 && r.items.every(i => selectedPaths.has(i.path));
        if (input) input.checked = allSelected;

        if (safety === 'safe') safeContainer.appendChild(card);
        else if (safety === 'moderate' && modContainer) modContainer.appendChild(card);
        else riskyContainer.appendChild(card);
    });

    updateSelectionStats();

    // Show/Hide Global Clean Button
    const btn = document.getElementById('global-clean-btn');
    if (btn) {
        if (selectedPaths.size > 0) btn.classList.remove('hidden');
        else btn.classList.add('hidden');
    }
}

function createCard(id, name, size, count, safety) {
    const card = document.createElement('div');
    card.className = `category-card ${safety}`;
    card.setAttribute('draggable', 'true');
    card.setAttribute('data-id', id);
    card.setAttribute('data-safety', safety);

    card.innerHTML = `
        <div class="card-checkbox">
            <input type="checkbox" onclick="event.stopPropagation()" onchange="toggleCategory('${id}', this.checked)">
        </div>
        <div class="card-header">
            <h3>${name}</h3>
            <span class="badge ${safety}">${safety}</span>
        </div>
        <div class="size">${formatSize(size)}</div>
        <div class="count">${count} items</div>
        <div class="progress-bar">
            <div class="progress-bar-fill" style="width: ${size > 0 ? '100%' : '0%'}"></div>
        </div>
        <div class="progress-text"></div>
    `;

    // Click to open details
    card.onclick = (e) => {
        if (e.target.classList.contains('drag-handle')) return;
        if (scanData) {
            const result = scanData.results.find(r => r.category.id === id);
            if (result) openCategory(result.category);
        }
    };

    // Drag Events
    card.addEventListener('dragstart', dragStart);
    return card;
}

// Drag logic
let draggedCard = null;

function dragStart(e) {
    draggedCard = this;
    e.dataTransfer.effectAllowed = 'move';
    setTimeout(() => this.classList.add('dragging'), 0);
}

// Drop Zones
['safe-categories', 'moderate-categories', 'risky-categories'].forEach(id => {
    const zone = document.getElementById(id);
    if (!zone) return;

    zone.addEventListener('dragover', e => {
        e.preventDefault(); // Allow drop
        const afterElement = getDragAfterElement(zone, e.clientY);
        const dragging = document.querySelector('.dragging');
        if (afterElement == null) {
            zone.appendChild(dragging);
        } else {
            zone.insertBefore(dragging, afterElement);
        }
    });

    zone.addEventListener('drop', async e => {
        const dragging = document.querySelector('.dragging');
        dragging.classList.remove('dragging');

        // Determine new safety based on parent
        let newSafety = 'risky';
        if (zone.id === 'safe-categories') newSafety = 'safe';
        if (zone.id === 'moderate-categories') newSafety = 'moderate';

        const cardId = dragging.getAttribute('data-id');

        // Save override
        categoryOverrides[cardId] = newSafety;

        // Show Save Button hint? Or just auto-save?
        // Let's auto-save for UX
        await fetch('/api/settings/layout', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ categoryOverrides })
        });

        // Update visual style AND badge
        dragging.className = `category-card ${newSafety}`;
        dragging.setAttribute('data-safety', newSafety);

        // Update badge text and class
        const badge = dragging.querySelector('.badge');
        if (badge) {
            badge.className = `badge ${newSafety}`;
            badge.textContent = newSafety;
        }
    });
});

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.category-card:not(.dragging)')];

    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

// --- Other Logic (Copied/Modified from V2) --- 
// ... (Keep existing loadDiskInfo, results view, blacklist, history logic) ...
// We need to reimplement them or append them.
// For brevity, I will inject the key parts and keep previous functions.

// Navigation
window.showSection = (sectionId) => {
    document.querySelectorAll('.nav-item').forEach(btn => {
        if (btn.getAttribute('onclick').includes(sectionId)) btn.classList.add('active');
        else btn.classList.remove('active');
    });
    ['dashboard', 'scan-results', 'blacklist', 'history', 'settings'].forEach(id => {
        const el = document.getElementById(id);
        if (id === sectionId) {
            el.classList.add('active');
            el.classList.remove('hidden');
            if (id === 'blacklist') loadBlacklist();
            if (id === 'history') loadHistory();
            if (id === 'settings') loadSettings();
        } else {
            el.classList.remove('active');
            el.classList.add('hidden');
        }
    });
};

async function loadDiskInfo() {
    try {
        const res = await fetch('/api/disk-info');
        const data = await res.json();
        const percent = Math.round((data.used / data.total) * 100);
        document.getElementById('disk-bar-fill').style.width = `${percent}%`;
        document.getElementById('disk-used').textContent = `${formatSize(data.used)} ${t('used')}`;
        document.getElementById('disk-free').textContent = `${formatSize(data.free)} ${t('free')}`;
    } catch (e) { }
}

window.openCategory = (category) => {
    currentCategory = category;
    showSection('scan-results');
    document.getElementById('category-title').textContent = category.name;
    renderFilesList();
};

function renderFilesList() {
    const container = document.getElementById('file-list');
    container.innerHTML = '';
    const result = scanData.results.find(r => r.category.id === currentCategory.id);
    if (!result) return;

    let items = [...result.items].sort((a, b) => b.size - a.size);
    const term = document.getElementById('search-input').value.toLowerCase();
    if (term) items = items.filter(i => i.name.toLowerCase().includes(term));

    items.forEach(item => {
        const row = document.createElement('div');
        row.className = 'file-row';
        const checked = selectedPaths.has(item.path);
        row.innerHTML = `
            <div class="col-check"><input type="checkbox" ${checked ? 'checked' : ''} onchange="toggleSelect('${item.path}', this.checked)"></div>
            <div class="col-allow"><input type="checkbox" class="ignore-check" onchange="ignoreFile('${item.path}')"></div>
            <div class="col-info"><span class="file-path">${item.path}</span></div>
            <div class="col-size">${formatSize(item.size)}</div>
        `;
        container.appendChild(row);
    });
    updateSelectionStats();
}

window.toggleSelect = (path, checked) => {
    if (checked) selectedPaths.add(path); else selectedPaths.delete(path);
    updateSelectionStats();
};

function updateSelectionStats() {
    if (document.getElementById('selection-stats')) {
        document.getElementById('selection-stats').textContent = `${selectedPaths.size} selected`;
    }
    document.getElementById('clean-btn').disabled = selectedPaths.size === 0;

    // Update Disk Projection
    calculateDiskProjection();
}

// --- Scheduler Logic ---
function updateScheduleInputs() {
    const freqEl = document.getElementById('schedule-freq');
    const weekday = document.getElementById('input-weekday');
    const day = document.getElementById('input-day');

    if (!freqEl || !weekday || !day) return;

    const freq = freqEl.value;

    // Simplified Toggle Logic
    const isWeekly = freq === 'weekly';
    const isMonthly = freq === 'monthly';

    // Toggle hidden class: Add if NOT matching frequency, Remove if matching
    if (isWeekly) weekday.classList.remove('hidden');
    else weekday.classList.add('hidden');

    if (isMonthly) day.classList.remove('hidden');
    else day.classList.add('hidden');

    // console.log(`Frequency: ${freq}, Weekly: ${isWeekly}, Monthly: ${isMonthly}`); 
}
window.updateScheduleInputs = updateScheduleInputs;

async function calculateDiskProjection() {
    // We need current disk info. It might be stale, but we can assume 'diskData' global if we store it
    // Or just store the 'used' and 'total' from initial load. This is cleaner.
    // Let's rely on DOM or global. Global is better.
    if (!window.diskData) return;

    let selectedSize = 0;
    if (scanData) {
        scanData.results.forEach(r => {
            r.items.forEach(i => {
                if (selectedPaths.has(i.path)) selectedSize += i.size;
            });
        });
    }

    const total = window.diskData.total;
    const used = window.diskData.used;
    const usedPercent = (used / total) * 100;
    const cleanPercent = (selectedSize / total) * 100;

    // We want to show the 'clean' part AT THE END of the 'used' bar.
    // CSS: .disk-bar-fill width is 'usedPercent'.
    // We want .disk-bar-projected to act as a "highlight" of the chunk to be removed.
    // So correct math:
    // Left = (used - selectedSize) / total * 100
    // Width = cleanPercent

    const left = ((used - selectedSize) / total) * 100;
    const el = document.getElementById('disk-bar-projected');
    const txt = document.getElementById('disk-projection-text');

    if (el && txt) {
        // Safety check if cleaning more than used (impossible theoretically but logic safety)
        const safeLeft = Math.max(0, left);

        el.style.left = `${safeLeft}%`;
        el.style.width = `${cleanPercent}%`;

        if (selectedSize > 0) {
            txt.textContent = `Expected free: +${formatSize(selectedSize)}`;
            el.style.opacity = '1';
        } else {
            txt.textContent = '';
            el.style.width = '0%';
            el.style.opacity = '0';
        }
    }
}

// Store disk data globally
async function loadDiskInfo() {
    try {
        const res = await fetch('/api/disk-info');
        const data = await res.json();
        window.diskData = data; // Store for projection

        const percent = Math.round((data.used / data.total) * 100);
        document.getElementById('disk-bar-fill').style.width = `${percent}%`;

        // Update text with more detail?
        document.getElementById('disk-used').textContent = `${formatSize(data.used)} Used`;
        document.getElementById('disk-free').textContent = `${formatSize(data.free)} Free`;
    } catch (e) { }
}

window.ignoreFile = async (path) => {
    // Immediate action, no confirmation
    try {
        await fetch('/api/ignore', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ paths: [path] }) });

        // Optimistic UI update
        if (scanData) {
            scanData.results.forEach(r => {
                r.items = r.items.filter(i => i.path !== path);
                r.totalSize = r.items.reduce((acc, i) => acc + i.size, 0);
            });
        }

        // Remove from selection if present
        if (selectedPaths.has(path)) {
            selectedPaths.delete(path);
            updateSelectionStats();
        }

        renderFilesList();
        renderDashboard(); // Update counts
    } catch (e) { console.error(e); }
};

window.confirmClean = async () => {
    const items = Array.from(selectedPaths);

    // Track which categories these items belong to
    const categoryNames = new Set();
    if (scanData && currentCategory) {
        categoryNames.add(currentCategory.name);
    }

    console.log('Cleaning items:', items);
    console.log('Categories:', Array.from(categoryNames));

    try {
        const response = await fetch('/api/clean', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                items,
                categories: Array.from(categoryNames)
            })
        });

        const result = await response.json();
        console.log('Clean result:', result);

        if (result.errors && result.errors.length > 0) {
            console.error('Clean errors:', result.errors);
            alert(`Cleaned ${result.count} items. Errors: ${result.errors.length}\nCheck console for details.`);
        } else {
            alert(`Successfully cleaned ${result.count} items!`);
        }

        selectedPaths.clear();
        alert('Click "Run Smart Scan" to refresh.');
    } catch (e) {
        console.error('Clean failed:', e);
        alert('Clean failed: ' + e.message);
    }
};

window.filterResults = () => renderFilesList();

// Blacklist & History
async function loadBlacklist() {
    const res = await fetch('/api/settings');
    const c = await res.json();
    document.querySelector('#blacklist-table tbody').innerHTML = (c.ignoredPaths || []).map(p =>
        `<tr>
            <td style="width: 100px; text-align:center;"><button class="text-btn danger" onclick="unignore('${p}')">Un-ignore</button></td>
            <td>${p}</td>
        </tr>`
    ).join('');
}
window.unignore = async (p) => {
    await fetch('/api/unignore', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ paths: [p] }) });
    loadBlacklist();
};
async function loadHistory() {
    const res = await fetch('/api/history');
    const logs = await res.json();
    document.querySelector('#history-table tbody').innerHTML = logs.map(l => {
        const date = new Date(l.timestamp);
        const dateStr = date.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric' });
        const timeStr = date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
        const categories = l.categories && l.categories.length > 0 ? l.categories.join(', ') : 'N/A';

        return `<tr>
            <td>${dateStr} ${timeStr}</td>
            <td>${categories}</td>
            <td>${l.itemsCount}</td>
            <td>${formatSize(l.totalFreed || 0)}</td>
        </tr>`;
    }).join('');
}

// Settings
async function loadSettings() {
    const res = await fetch('/api/settings');
    const c = await res.json();
    // document.getElementById('lang-select').value = c.language || 'en'; // Removed

    // Schedule
    const sched = c.autoCleanSchedule || {};
    document.getElementById('schedule-enable').checked = sched.enabled;
    document.getElementById('schedule-freq').value = sched.frequency || 'daily';
    document.getElementById('schedule-time').value = sched.time || '09:00';

    if (sched.day) {
        if (sched.frequency === 'weekly') document.getElementById('schedule-weekday').value = sched.day;
        if (sched.frequency === 'monthly') document.getElementById('schedule-day').value = sched.day;
    }

    // Delete Mode
    const mode = c.deleteMode || 'trash';
    const modeRadio = document.querySelector(`input[name="delete-mode"][value="${mode}"]`);
    if (modeRadio) modeRadio.checked = true;

    // Trigger UI update
    if (typeof updateScheduleInputs === 'function') {
        updateScheduleInputs();
    }

    // Auto Clean Categories
    const sRes = await fetch('/api/scanners');
    const scanners = await sRes.json();
    const container = document.getElementById('auto-clean-categories');
    if (container) {
        container.innerHTML = scanners.map(s => {
            const currentSafety = getSafety(s.id, s.safetyLevel);
            return `
            <label class="checkbox-label">
                <input type="checkbox" name="auto-cat" value="${s.id}" ${(sched.categories || []).includes(s.id) ? 'checked' : ''}>
                ${s.name} <span class="badge ${currentSafety}">${currentSafety}</span>
            </label>
        `;
        }).join('');
    }

    // Attach autosave
    attachAutoSave();
}

function attachAutoSave() {
    const inputs = document.querySelectorAll('#settings input, #settings select');
    inputs.forEach(input => {
        input.onchange = () => saveSettings(true);
    });

    // Explicit listener for frequency to update UI immediately
    const freqEl = document.getElementById('schedule-freq');
    if (freqEl) {
        freqEl.addEventListener('change', () => {
            updateScheduleInputs();
            saveSettings(true);
        });
    }
}

window.saveSettings = async (silent = false) => {
    // const lang = document.getElementById('lang-select').value; // Removed
    const enabled = document.getElementById('schedule-enable').checked;
    const freq = document.getElementById('schedule-freq').value;
    const time = document.getElementById('schedule-time').value;

    let day = undefined;
    if (freq === 'weekly') day = parseInt(document.getElementById('schedule-weekday').value);
    if (freq === 'monthly') day = parseInt(document.getElementById('schedule-day').value);

    const cats = Array.from(document.querySelectorAll('input[name="auto-cat"]:checked')).map(el => el.value);

    const deleteMode = document.querySelector('input[name="delete-mode"]:checked').value;

    const settings = {
        categoryOverrides,
        deleteMode,
        autoCleanSchedule: {
            enabled,
            frequency: freq,
            time,
            day,
            categories: cats
        }
    };

    try {
        await fetch('/api/settings', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(settings) });
        config = { ...config, ...settings }; // Update local state
        updateTexts(); // Refresh UI texts immediately
        if (!silent) {
            // Optional visual feedback
        }
    } catch (e) {
        console.error(e);
    }
};

// Auto-save listeners helper
// Removed duplicate attachAutoSave
// The main one is defined above at line 571

// New Helpers
window.toggleCategory = (id, checked) => {
    if (!scanData) return;
    const result = scanData.results.find(r => r.category.id === id);
    if (!result) return;

    result.items.forEach(item => {
        if (checked) selectedPaths.add(item.path);
        else selectedPaths.delete(item.path);
    });

    updateSelectionStats();
    calculateDiskProjection();

    // If in detail view, update checkboxes there too
    if (currentCategory && currentCategory.id === id) {
        renderFilesList();
    }

    // Update dashboard visual if needed (re-render or just toggle)
    // Re-rendering handles "select all" state check
    renderDashboard();
};

window.cleanSelectedCategories = async () => {
    if (selectedPaths.size === 0) return;

    const items = Array.from(selectedPaths);

    // Track which categories these items belong to
    const categoryNames = new Set();
    if (scanData) {
        scanData.results.forEach(r => {
            const hasItems = r.items.some(item => selectedPaths.has(item.path));
            if (hasItems) {
                categoryNames.add(r.category.name);
            }
        });
    }

    console.log('Cleaning items:', items);
    console.log('Categories:', Array.from(categoryNames));

    try {
        const response = await fetch('/api/clean', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                items,
                categories: Array.from(categoryNames)
            })
        });

        const result = await response.json();
        console.log('Clean result:', result);

        if (result.errors && result.errors.length > 0) {
            console.error('Clean errors:', result.errors);
            alert(`Cleaned ${result.count} items. Errors: ${result.errors.length}\nCheck console for details.`);
        } else {
            alert(`Successfully cleaned ${result.count} items!`);
        }

        selectedPaths.clear();
        alert('Click "Run Smart Scan" to refresh.');
    } catch (e) {
        console.error('Clean failed:', e);
        alert('Clean failed: ' + e.message);
    }
};

window.resetCategoryLayout = async () => {
    if (!confirm('Reset all categories to their original safety levels?')) return;

    // Clear overrides
    categoryOverrides = {};

    // Save empty overrides
    await fetch('/api/settings/layout', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ categoryOverrides: {} })
    });

    // Re-render dashboard with original safety levels
    if (scanData) {
        renderDashboard();
    } else {
        // If no scan data, reload scanners metadata
        try {
            const res = await fetch('/api/scanners');
            const scanners = await res.json();
            renderEmptyDashboard(scanners);
        } catch (e) {
            console.error(e);
        }
    }

    alert('Layout reset to original safety levels!');
};
